# PushElement

The integration point closest to yielding
(upon a positive strain increase)
of a preselected element,
and compute force equilibrium.

>   (For the moment) Only only those configurations that lead to a
>   system-spanning event at the first push are run.
>   Furthermore, iterative pushing is stopped if an event was
>   small (`A < 100`).
>   This protocol seems scientifically the most reasonable, but
>   can always be expanded later.

The protocol is as follows:

## job_branchsims.py

The start configurations "push = 0" are taken as the configuration after
a system-spanning event during normal (event-driven) simple shear.
The script `job_branchsis.py` takes care of this,
Several branches per `id=XXX.hdf5` with the same starting configuration
are made in  the files `id=XXX_element=X_inc=X.hdf5`,
whereby `element=X` indicated the element that will be pushed.

## PushElement

The executable `PushElement` then applies pushes "push = 1, 2, ..."
to the integration point closest to yielding until nothing triggers
anymore (see criterion above).
The configuration at mechanical equilibrium, after each sequential push
is stored by means of the displacement field to `id=XXX_inc=X.hdf5`
(that contained the displacement before the first push already).
At the same time, the time evolution of each push is written to
a separate output file `id=XXX_inc=X_push=X.hdf5`.
The latter can thus be regenerated by running one increment maximum.

## job_serial.py

To run on the cluster, `job_serial.py` can generate a single-CPU
job per `id=XXX_inc=X.hdf5`.
Note that it will automatically skip all files marked as
completed.

## list_status.py

After a run `list_status.py` can be used to collect information
on all files `id=XXX_element=X_inc=X.hdf5` and `id=XXX_element=X_inc=X_push=X.hdf5`.
It writes a file `list_status.yaml` that can then be use e.g.
to copy data.
